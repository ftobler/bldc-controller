/*
 * taskmanager.cpp
 *
 *  Created on: Apr 17, 2024
 *      Author: ftobler
 */

#include "stm32_hal.h"
#include "taskmanager.h"
#include "flortos.h"
#include "application.h"
#include "main.h"
#include "protocol.h"
#include "autogenerated_modbus.h"
#include "as5600.h"
#include "motor.h"
#include "sine.h"

enum {
	STD_STACK_SIZE = 1024
};

static uint8_t stack_idle_task[STD_STACK_SIZE];
static uint8_t stack_led_task[STD_STACK_SIZE];
static uint8_t stack_application_task[STD_STACK_SIZE];
static uint8_t stack_protocol_task[STD_STACK_SIZE];
static uint8_t stack_motor_0_task[STD_STACK_SIZE];
static uint8_t stack_motor_1_task[STD_STACK_SIZE];
static uint8_t stack_motor_2_task[STD_STACK_SIZE];

static void idle_task_fn();
static void led_task_fn();
static void application_task_fn();
static void protocol_task_fn();
static void motor_0_task_fn();
static void motor_1_task_fn();
static void motor_2_task_fn();

extern Database_value_t database_value;
uint32_t enable_automatic = 0;

extern Motor motors[3];

void taskmanager_init() {
	scheduler_init();
	scheduler_addTask(TASK_ID_IDLE, idle_task_fn, stack_idle_task, STD_STACK_SIZE); //lowest priority
	scheduler_addTask(TASK_ID_LED, led_task_fn, stack_led_task, STD_STACK_SIZE);
	scheduler_addTask(TASK_ID_PROTOCOL, protocol_task_fn, stack_protocol_task, STD_STACK_SIZE);
	scheduler_addTask(TASK_ID_APPLICATION, application_task_fn, stack_application_task, STD_STACK_SIZE);
	scheduler_addTask(TASK_ID_MOTOR_0, motor_0_task_fn, stack_motor_0_task, STD_STACK_SIZE);
	scheduler_addTask(TASK_ID_MOTOR_1, motor_1_task_fn, stack_motor_1_task, STD_STACK_SIZE);
	scheduler_addTask(TASK_ID_MOTOR_2, motor_2_task_fn, stack_motor_2_task, STD_STACK_SIZE); //highest priority
	scheduler_join();
}

static void idle_task_fn() {
	while (1) {
		//as5600_poll();
	}
}

static void led_task_fn() {
	while (1) {
		LED1_GPIO_Port->BSRR = LED1_Pin;
		scheduler_task_sleep(25);
		LED1_GPIO_Port->BRR = LED1_Pin;

		LED2_GPIO_Port->BSRR = LED2_Pin;
		scheduler_task_sleep(25);
		LED2_GPIO_Port->BRR = LED2_Pin;

		LED3_GPIO_Port->BSRR = LED3_Pin;
		scheduler_task_sleep(25);
		LED3_GPIO_Port->BRR = LED3_Pin;

		LED4_GPIO_Port->BSRR = LED4_Pin;
		scheduler_task_sleep(25);
		LED4_GPIO_Port->BRR = LED4_Pin;
	}
}

static void protocol_task_fn() {
	protocol_init();
	while (1) {
		scheduler_event_wait(EVENT_PROTOCOL_UART_IDLE);
		protocol_loop();
	}
}

static void application_task_fn() {
	sine_init();
	application_setup();
	scheduler_event_set(TASK_ID_MOTOR_0, EVENT_MOTOR_0_START);
	scheduler_event_set(TASK_ID_MOTOR_1, EVENT_MOTOR_1_START);
	scheduler_event_set(TASK_ID_MOTOR_2, EVENT_MOTOR_2_START);
	while (1) {
		scheduler_event_wait(EVENT_APPLICATION_TIMER);
		application_loop();
//		scheduler_task_sleep(1);
	}
}

static void motor_0_task_fn() {
	Motor* motor = &motors[0];
	scheduler_event_wait(EVENT_MOTOR_0_START);
	motor->calibrate();
	while (1) {
		scheduler_event_wait(EVENT_MOTOR_0_PWM);
		motor->update();
	}
}
static void motor_1_task_fn() {
	Motor* motor = &motors[1];
	scheduler_event_wait(EVENT_MOTOR_1_START);
	motor->calibrate();
	while (1) {
		scheduler_event_wait(EVENT_MOTOR_1_PWM);
		motor->update();
	}
}
static void motor_2_task_fn() {
	Motor* motor = &motors[2];
	scheduler_event_wait(EVENT_MOTOR_2_START);
	motor->calibrate();
	while (1) {
		scheduler_event_wait(EVENT_MOTOR_2_PWM);
		motor->update();
	}
}


