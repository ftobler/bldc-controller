/*
 * application.cpp
 *
 *  Created on: Apr 17, 2024
 *      Author: ftobler
 */


#include "stm32_hal.h"
#include "application.h"
#include "main.h"
#include "flortos.h"
#include "autogenerated_modbus.h"
#include "motor.h"
#include "sine.h"




uint32_t adc_dma_results[4];

extern ADC_HandleTypeDef hadc1;
extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim3;
extern TIM_HandleTypeDef htim15;





Motor motors[3];

int32_t vcc_mv = 0;


extern Database_value_t database_value;


void application_setup() {

	//configure motor 0 struct
	motors[0].pwm[0] = &(htim1.Instance->CCR3);
	motors[0].pwm[1] = &(htim1.Instance->CCR2);
	motors[0].pwm[2] = &(htim1.Instance->CCR1);
	motors[0].en_port = ENABLE_M1_GPIO_Port;
	motors[0].en_pin = ENABLE_M1_Pin;
	motors[0].dma_index = 0;
//	motors[0].coef_a = 1.75f;
//	motors[0].coef_b = -291.763092f;
//	motors[0].calibrated = 1;
	//configure motor 1 struct
	motors[1].pwm[0] = &(htim3.Instance->CCR4);
	motors[1].pwm[1] = &(htim3.Instance->CCR3);
	motors[1].pwm[2] = &(htim3.Instance->CCR2);
	motors[1].en_port = ENABLE_M2_GPIO_Port;
	motors[1].en_pin = ENABLE_M2_Pin;
	motors[1].dma_index = 1;
//	motors[1].coef_a = 1.75f;
//	motors[1].coef_b = -359.899902f;
//	motors[1].calibrated = 1;
	motors[1].reverse_field();
	//configure motor 2 struct
	motors[2].pwm[0] = &(htim3.Instance->CCR1);
	motors[2].pwm[1] = &(htim15.Instance->CCR2);
	motors[2].pwm[2] = &(htim15.Instance->CCR1);
	motors[2].en_port = ENABLE_M3_GPIO_Port;
	motors[2].en_pin = ENABLE_M3_Pin;
	motors[2].dma_index = 2;
	motors[2].reverse_field();
//	motors[2].coef_a = 1.75f;
//	motors[2].coef_b = -658.282288f;
//	motors[2].calibrated = 1;

	//start the timers, start pwm, one timer in interrupt mode.
	HAL_TIM_Base_Start(&htim1);
	HAL_TIM_Base_Start(&htim3);
	HAL_TIM_Base_Start_IT(&htim15);
	htim15.Instance->ARR = PWM_MAX-1;
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_1);

	//start ADC DMA to continiously write oversampled values in
	//a buffer. ADC is preconfigured to do this.
	HAL_ADC_Start_DMA(&hadc1, adc_dma_results, 4);

	scheduler_task_sleep(300); //wait for power to be more stable

	//switch PWM on
	for (int i = 0; i < 3; i++) {
//		*motors[i].pwm[0] = i * 300 + 100;
//		*motors[i].pwm[1] = i * 300 + 200;
//		*motors[i].pwm[2] = i * 300 + 300;
		motors[i].en_port->BSRR = motors[i].en_pin;
	}

}

__attribute__((optimize("Ofast"))) void application_loop() {

	//calculate vcc
	vcc_mv = adc_dma_results[3] * 33000 / 4096;

//	motors[0].target = 2000 + 1500*sinf(uwTick / 500.0f);
//	motors[1].target = 2000 + 1500*sinf((uwTick+333) / 500.0f);
//	motors[2].target = 2000 + 1500*sinf((uwTick+666) / 500.0f);

//	if (motors[0].calibrated) {
//		motors[0].max_pwm = 900;
//	}
//	if (motors[1].calibrated) {
//		motors[1].max_pwm = 900;
//	}
//	if (motors[2].calibrated) {
//		motors[2].max_pwm = 900;
//	}

	motors[0].target = 1750 + 900*sine(uwTick / 150.0f);
	motors[1].target = motors[0].encoder + 450*sine(uwTick / 50.0f);
	motors[2].target = motors[1].encoder + 300*sine(uwTick / 30.0f);
}



