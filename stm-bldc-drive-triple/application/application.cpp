/*
 * application.cpp
 *
 *  Created on: Apr 17, 2024
 *      Author: ftobler
 */


#include "stm32_hal.h"
#include "application.h"
#include "main.h"
#include "flortos.h"
#include "autogenerated_modbus.h"

enum {
};


uint32_t adc_dma_results[4];

extern ADC_HandleTypeDef hadc1;
extern TIM_HandleTypeDef htim1;
extern TIM_HandleTypeDef htim3;
extern TIM_HandleTypeDef htim15;


typedef struct {
	volatile uint32_t* pwm[3]; //pointer to pwm registers
	volatile GPIO_TypeDef* en_port; //enable port
	uint16_t en_pin; //enable pin
	uint32_t dma_index; //index of the sensor feedback
} Motor_t;


Motor_t motors[3] = {0};


extern Database_value_t database_value;


void application_setup() {

	motors[0].pwm[0] = &(htim1.Instance->CCR3);
	motors[0].pwm[1] = &(htim1.Instance->CCR2);
	motors[0].pwm[2] = &(htim1.Instance->CCR1);
	motors[0].en_port = ENABLE_M1_GPIO_Port;
	motors[0].en_pin = ENABLE_M1_Pin;
	motors[1].pwm[0] = &(htim3.Instance->CCR4);
	motors[1].pwm[1] = &(htim3.Instance->CCR3);
	motors[1].pwm[2] = &(htim3.Instance->CCR2);
	motors[1].en_port = ENABLE_M2_GPIO_Port;
	motors[1].en_pin = ENABLE_M2_Pin;
	motors[2].pwm[0] = &(htim3.Instance->CCR1);
	motors[2].pwm[1] = &(htim15.Instance->CCR2);
	motors[2].pwm[2] = &(htim15.Instance->CCR1);
	motors[2].en_port = ENABLE_M3_GPIO_Port;
	motors[2].en_pin = ENABLE_M3_Pin;

	HAL_TIM_Base_Start(&htim1);
	HAL_TIM_Base_Start(&htim3);
	HAL_TIM_Base_Start_IT(&htim15);
	htim15.Instance->ARR = 6400-1; //10kHz
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_1);

	HAL_ADC_Start_DMA(&hadc1, adc_dma_results, 4);

	for (int i = 0; i < 3; i++) {
		*motors[i].pwm[0] = i * 300 + 100;
		*motors[i].pwm[1] = i * 300 + 200;
		*motors[i].pwm[2] = i * 300 + 300;
		motors[i].en_port->BSRR = motors[i].en_pin;
	}


//	htim1.Instance->CCR3 = 100;
//	htim1.Instance->CCR2 = 200;
//	htim1.Instance->CCR1 = 300;
//	htim3.Instance->CCR4 = 400;
//	htim3.Instance->CCR3 = 500;
//	htim3.Instance->CCR2 = 600;
//	htim3.Instance->CCR1 = 700;
//	htim15.Instance->CCR2 = 800;
//	htim15.Instance->CCR1 = 900;
//
//	ENABLE_M1_GPIO_Port->BSRR = ENABLE_M1_Pin;
//	ENABLE_M2_GPIO_Port->BSRR = ENABLE_M2_Pin;
//	ENABLE_M3_GPIO_Port->BSRR = ENABLE_M3_Pin;


	scheduler_task_sleep(300); //wait for power to be more stable

	//switch SKIP pin, this will enable the drivers from Diode mode to PWM mode

}

__attribute__((optimize("Ofast"))) void application_loop() {

}


__attribute__((optimize("Ofast"))) void control_loop() {

}
